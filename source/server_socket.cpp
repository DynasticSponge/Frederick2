//
// server_socket.cpp
// ~~~~~~~~~~~~~~~~~
//
// Author: Joseph Adomatis
// Copyright (c) 2020 Joseph R Adomatis (joseph dot adomatis at gmail dot com)
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <cstring>
#include <memory>
#include <netdb.h>
#include <poll.h>
#include <string>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include "../headers/frederick2_namespace.hpp"
#include "../headers/server_socket.hpp"

namespace server = frederick2::httpServer;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// global variable definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// global function definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// frederick2::network::socket member definitions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Constructor
///////////////////////////////////////////////////////////////////////////////

server::socket::socket(const std::string& strAddr, const std::string& strPort)
{
    this->pollFD.events = POLLIN | POLLOUT;

    struct addrinfo hints;
    struct addrinfo *result;
    struct addrinfo *resultIter;
    int addrInfoErr{-1};
    int bindResult{-1};
    
    ///////////////////////////////////////////////////////////////////////////////
    // build up the C addrinfo structure for hints
    // getaddrinfo will use these to filter which socket addresses to return 
    ///////////////////////////////////////////////////////////////////////////////

    memset(&hints, '\0', sizeof(struct addrinfo));
    ///////////////////////////////////////////////////////////////////////////////
    // looking for ipv4 addresses only
    ///////////////////////////////////////////////////////////////////////////////
    
    hints.ai_family = AF_INET;
    
    ///////////////////////////////////////////////////////////////////////////////
    // looking for TCP addresses only
    ///////////////////////////////////////////////////////////////////////////////
    
    hints.ai_socktype = SOCK_STREAM;
    
    ///////////////////////////////////////////////////////////////////////////////
    // will be providing numeric ipv4 ***.***.***.***
    // will be providing numeric port
    // these keep getaddrinfo from doing dns lookups
    ///////////////////////////////////////////////////////////////////////////////
    
    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;

    ///////////////////////////////////////////////////////////////////////////////
    // socket can be for any protocol
    ///////////////////////////////////////////////////////////////////////////////
    hints.ai_protocol = 0;

    ///////////////////////////////////////////////////////////////////////////////
    // mandatory flags
    ///////////////////////////////////////////////////////////////////////////////
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    
    ///////////////////////////////////////////////////////////////////////////////
    // run getaddrinfo
    // pass in numeric address as string,
    // pass in numeric port as string
    // pass in hints structure
    // pass in empty array for results
    ///////////////////////////////////////////////////////////////////////////////
    addrInfoErr = getaddrinfo(strAddr.c_str(), strPort.c_str(), &hints, &result);
    if (addrInfoErr != 0) {
        std::string errMsg{"getaddrinfo: "};
        errMsg.append(gai_strerror(addrInfoErr));
        throw std::runtime_error(errMsg);
    }

    ///////////////////////////////////////////////////////////////////////////////
    // getaddrinfo returns array of address structures.
    // try to create socket and bind using info from each address structure
    // exit loop first time we get a succss on both
    ///////////////////////////////////////////////////////////////////////////////
    
    for (resultIter = result; resultIter != NULL; resultIter = resultIter->ai_next) {
        this->sock = ::socket(resultIter->ai_family, resultIter->ai_socktype, resultIter->ai_protocol);
        if (this->sock < 0)
        {
            ///////////////////////////////////////////////////////////////////////////////
            // could not create socket with this addr info
            ///////////////////////////////////////////////////////////////////////////////
    
            continue;
        }
        bindResult = ::bind(this->sock, resultIter->ai_addr, resultIter->ai_addrlen);
        if(bindResult == 0)
        {
            ///////////////////////////////////////////////////////////////////////////////
            // could not bind socket with this addr info
            ///////////////////////////////////////////////////////////////////////////////
    
            break;
        }
        ::close(this->sock);
    }

    if (resultIter == NULL)
    {
        ///////////////////////////////////////////////////////////////////////////////
        // could not create socket and bind with any of the address info structs
        ///////////////////////////////////////////////////////////////////////////////
    
        std::string errMsg{"Could not bind socket to address: "};
        errMsg.append(strAddr);
        errMsg.append(" port: ");
        errMsg.append(strPort);
        throw std::runtime_error(errMsg);
    }
    
    freeaddrinfo(result);
}

///////////////////////////////////////////////////////////////////////////////
// frederick2::network::socket::close
///////////////////////////////////////////////////////////////////////////////

void server::socket::close()
{
    ::close(this->sock);
}

///////////////////////////////////////////////////////////////////////////////
// frederick2::network::socket::getFD
///////////////////////////////////////////////////////////////////////////////

int server::socket::getFD()
{
    return(this->sock);
}

///////////////////////////////////////////////////////////////////////////////
// frederick2::network::socket::listen
///////////////////////////////////////////////////////////////////////////////

bool server::socket::listen(int queueLength)
{
    bool returnValue = true;

    int listenResult = ::listen(this->sock, queueLength);
    if (listenResult < 0)
    {
        returnValue = false;
    }

    this->pollFD.fd = this->sock;
    return(returnValue);
}

///////////////////////////////////////////////////////////////////////////////
// frederick2::network::socket::pollIn
///////////////////////////////////////////////////////////////////////////////

bool server::socket::pollIn()
{
    bool returnValue{false};
    int pollReturn{-1};

    pollReturn = poll(&this->pollFD, 1, 0);

    if (pollReturn > 0)
    {
        if (this->pollFD.revents & POLLIN)
        {
            returnValue = true;
        }
    }
    return(returnValue);
}

///////////////////////////////////////////////////////////////////////////////
// Deconstructor
///////////////////////////////////////////////////////////////////////////////

server::socket::~socket()
{
    ::close(this->sock);
}
